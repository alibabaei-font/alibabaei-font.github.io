import React, { useState, useRef, useEffect } from 'react';
import { Download, Eraser, PaintBucket, Pencil, Trash2, Grid, Pipette, Undo, Redo, Palette, Monitor } from 'lucide-react';

export default function AliKufiApp() {
  // --- Refs (For Performance) ---
  // استفاده از Ref برای داده‌های پیکسلی باعث می‌شود سرعت رسم بسیار بالا برود و لگ نداشته باشد
  const pixelsRef = useRef({}); 
  const canvasRef = useRef(null);
  const containerRef = useRef(null);

  // --- State (For UI) ---
  const [gridSize, setGridSize] = useState(32); // 16, 32, 64
  const [selectedColor, setSelectedColor] = useState('#3b82f6');
  const [tool, setTool] = useState('pencil'); // pencil, eraser, bucket, picker
  const [showGrid, setShowGrid] = useState(true);
  const [history, setHistory] = useState([{}]);
  const [historyIndex, setHistoryIndex] = useState(0);
  const [isDrawing, setIsDrawing] = useState(false);
  const [updateTrigger, setUpdateTrigger] = useState(0); // Forcing re-renders when needed

  // Palettes
  const palettes = [
    ['#1a1c2c', '#5d275d', '#b13e53', '#ef7d57', '#ffcd75', '#a7f070', '#38b764', '#257179', '#29366f', '#3b5dc9', '#41a6f6', '#73eff7', '#f4f4f4', '#94b0c2', '#566c86', '#333c57'],
    ['#000000', '#9D9D9D', '#FFFFFF', '#BE2633', '#E06F8B', '#493C2B', '#A46422', '#EB8931', '#F7E26B', '#2F484E', '#44891A', '#A3CE27', '#1B2632', '#005784', '#31A2F2', '#B2DCEF']
  ];

  // --- Core Functions ---

  // Redraw the entire canvas from pixelsRef
  const redrawCanvas = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const pixelSize = canvas.width / gridSize;

    // Clear
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw Pixels
    const currentPixels = pixelsRef.current;
    Object.keys(currentPixels).forEach(key => {
      const [x, y] = key.split(',').map(Number);
      ctx.fillStyle = currentPixels[key];
      ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
    });

    // Draw Grid
    if (showGrid) {
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
      ctx.lineWidth = 0.5;
      ctx.beginPath();
      for (let i = 0; i <= gridSize; i++) {
        ctx.moveTo(i * pixelSize, 0);
        ctx.lineTo(i * pixelSize, canvas.height);
        ctx.moveTo(0, i * pixelSize);
        ctx.lineTo(canvas.width, i * pixelSize);
      }
      ctx.stroke();
    }
  };

  // Draw a single pixel immediately (optimization)
  const drawSinglePixel = (x, y, color) => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const pixelSize = canvas.width / gridSize;

    if (color === null) {
        // Eraser logic is tricky in single draw, easier to just clear rect and redraw grid if needed
        // But for speed, we can clear the rect. The grid might be lost in that cell until next redraw, which is fine.
        ctx.clearRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
    } else {
        ctx.fillStyle = color;
        ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
    }
    
    // Re-draw grid lines for this cell if grid is on
    if (showGrid) {
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.lineWidth = 0.5;
        ctx.strokeRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
    }
  };

  // Update effect
  useEffect(() => {
    redrawCanvas();
  }, [gridSize, showGrid, updateTrigger]); // Re-run when these change

  // --- History Management ---
  const saveHistory = () => {
    const newHistory = history.slice(0, historyIndex + 1);
    // Deep copy current pixels
    newHistory.push({ ...pixelsRef.current });
    if (newHistory.length > 30) newHistory.shift();
    
    setHistory(newHistory);
    setHistoryIndex(newHistory.length - 1);
  };

  const undo = () => {
    if (historyIndex > 0) {
      const newIndex = historyIndex - 1;
      setHistoryIndex(newIndex);
      pixelsRef.current = { ...history[newIndex] };
      redrawCanvas();
    }
  };

  const redo = () => {
    if (historyIndex < history.length - 1) {
