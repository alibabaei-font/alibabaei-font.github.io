import React, { useState, useRef, useEffect } from 'react';
import { Download, Eraser, PaintBucket, Pencil, Trash2, Grid, Pipette, Undo, Redo, Palette, Monitor } from 'lucide-react';

export default function AliKufiApp() {
  // --- Refs (For Performance) ---
  // استفاده از Ref برای داده‌های پیکسلی باعث می‌شود سرعت رسم بسیار بالا برود و لگ نداشته باشد
  const pixelsRef = useRef({}); 
  const canvasRef = useRef(null);
  const containerRef = useRef(null);

  // --- State (For UI) ---
  const [gridSize, setGridSize] = useState(32); // 16, 32, 64
  const [selectedColor, setSelectedColor] = useState('#3b82f6');
  const [tool, setTool] = useState('pencil'); // pencil, eraser, bucket, picker
  const [showGrid, setShowGrid] = useState(true);
  const [history, setHistory] = useState([{}]);
  const [historyIndex, setHistoryIndex] = useState(0);
  const [isDrawing, setIsDrawing] = useState(false);
  const [updateTrigger, setUpdateTrigger] = useState(0); // Forcing re-renders when needed

  // Palettes
  const palettes = [
    ['#1a1c2c', '#5d275d', '#b13e53', '#ef7d57', '#ffcd75', '#a7f070', '#38b764', '#257179', '#29366f', '#3b5dc9', '#41a6f6', '#73eff7', '#f4f4f4', '#94b0c2', '#566c86', '#333c57'],
    ['#000000', '#9D9D9D', '#FFFFFF', '#BE2633', '#E06F8B', '#493C2B', '#A46422', '#EB8931', '#F7E26B', '#2F484E', '#44891A', '#A3CE27', '#1B2632', '#005784', '#31A2F2', '#B2DCEF']
  ];

  // --- Core Functions ---

  // Redraw the entire canvas from pixelsRef
  const redrawCanvas = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const pixelSize = canvas.width / gridSize;

    // Clear
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw Pixels
    const currentPixels = pixelsRef.current;
    Object.keys(currentPixels).forEach(key => {
      const [x, y] = key.split(',').map(Number);
      ctx.fillStyle = currentPixels[key];
      ctx.fillRect(x  pixelSize, y  pixelSize, pixelSize, pixelSize);
    });

    // Draw Grid
    if (showGrid) {
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
      ctx.lineWidth = 0.5;
      ctx.beginPath();
      for (let i = 0; i <= gridSize; i++) {
        ctx.moveTo(i  pixelSize, 0);
        ctx.lineTo(i  pixelSize, canvas.height);
        ctx.moveTo(0, i  pixelSize);
        ctx.lineTo(canvas.width, i  pixelSize);
      }
      ctx.stroke();
    }
  };

  // Draw a single pixel immediately (optimization)
  const drawSinglePixel = (x, y, color) => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const pixelSize = canvas.width / gridSize;

    if (color === null) {
        // Eraser logic is tricky in single draw, easier to just clear rect and redraw grid if needed
        // But for speed, we can clear the rect. The grid might be lost in that cell until next redraw, which is fine.
        ctx.clearRect(x  pixelSize, y  pixelSize, pixelSize, pixelSize);
    } else {
        ctx.fillStyle = color;
        ctx.fillRect(x  pixelSize, y  pixelSize, pixelSize, pixelSize);
    }

    // Re-draw grid lines for this cell if grid is on
    if (showGrid) {
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.lineWidth = 0.5;
        ctx.strokeRect(x  pixelSize, y  pixelSize, pixelSize, pixelSize);
    }
  };

  // Update effect
  useEffect(() => {
    redrawCanvas();
  }, [gridSize, showGrid, updateTrigger]); // Re-run when these change

  // --- History Management ---
  const saveHistory = () => {
    const newHistory = history.slice(0, historyIndex + 1);
    // Deep copy current pixels
    newHistory.push({ ...pixelsRef.current });
    if (newHistory.length > 30) newHistory.shift();

    setHistory(newHistory);
    setHistoryIndex(newHistory.length - 1);
  };

  const undo = () => {
    if (historyIndex > 0) {
      const newIndex = historyIndex - 1;
      setHistoryIndex(newIndex);
      pixelsRef.current = { ...history[newIndex] };
      redrawCanvas();
    }
  };

  const redo = () => {
    if (historyIndex < history.length - 1) {

const newIndex = historyIndex + 1;
      setHistoryIndex(newIndex);
      pixelsRef.current = { ...history[newIndex] };
      redrawCanvas();
    }
  };

  // --- Interaction Logic ---
  const getCoords = (e) => {
    const canvas = canvasRef.current;
    if (!canvas) return { x: 0, y: 0 };
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;

    let cx, cy;
    if (e.touches && e.touches.length > 0) {
      cx = e.touches[0].clientX;
      cy = e.touches[0].clientY;
    } else {
      cx = e.clientX;
      cy = e.clientY;
    }

    const x = Math.floor((cx - rect.left)  scaleX / (canvas.width / gridSize));
    const y = Math.floor((cy - rect.top)  scaleY / (canvas.height / gridSize));
    return { x, y };
  };

  const applyTool = (x, y) => {
    if (x < 0 || x >= gridSize || y < 0 || y >= gridSize) return;
    const key = `${x},${y}`;

    if (tool === 'pencil') {
      if (pixelsRef.current[key] !== selectedColor) {
        pixelsRef.current[key] = selectedColor;
        drawSinglePixel(x, y, selectedColor);
      }
    } else if (tool === 'eraser') {
      if (pixelsRef.current[key]) {
        delete pixelsRef.current[key];
        drawSinglePixel(x, y, null);
      }
    } else if (tool === 'picker') {
      const color = pixelsRef.current[key];
      if (color) {
        setSelectedColor(color);
        setTool('pencil');
      }
    }
  };

  const floodFill = (startX, startY) => {
    const key = `${startX},${startY}`;
    const targetColor = pixelsRef.current[key];
    if (targetColor === selectedColor) return;

    const queue = [[startX, startY]];
    const visited = new Set();
    const newPixels = { ...pixelsRef.current };

    while (queue.length > 0) {
        const [x, y] = queue.pop();
        const k = `${x},${y}`;

        if (visited.has(k)) continue;
        if (x < 0 || x >= gridSize || y < 0 || y >= gridSize) continue;

        if (newPixels[k] === targetColor) {
            newPixels[k] = selectedColor;
            visited.add(k);
            queue.push([x+1, y], [x-1, y], [x, y+1], [x, y-1]);
        }
    }

    pixelsRef.current = newPixels;
    redrawCanvas();
    saveHistory();
  };

  const handleStart = (e) => {
    const { x, y } = getCoords(e);
    if (tool === 'bucket') {
      floodFill(x, y);
    } else {
      setIsDrawing(true);
      applyTool(x, y);
    }
  };

  const handleMove = (e) => {
    if (!isDrawing) return;
    if (tool === 'bucket') return;
    const { x, y } = getCoords(e);
    applyTool(x, y);
  };

  const handleEnd = () => {
    if (isDrawing) {
      setIsDrawing(false);
      saveHistory();
    }
  };

  // --- Export & Reset ---
  const handleExport = () => {
    const canvas = document.createElement('canvas');
    const scale = 32; // Super HD
    canvas.width = gridSize  scale;
    canvas.height = gridSize  scale;
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;

    Object.keys(pixelsRef.current).forEach(key => {
      const [x, y] = key.split(',').map(Number);
      ctx.fillStyle = pixelsRef.current[key];
      ctx.fillRect(x  scale, y  scale, scale, scale);
    });

    const link = document.createElement('a');
    link.download = `ali-kufi-export-${Date.now()}.png`;
    link.href = canvas.toDataURL('image/png');
    link.click();
  };

  const clearAll = () => {
    if (window.confirm('همه چیز پاک شود؟')) {
      pixelsRef.current = {};
      redrawCanvas();
      saveHistory();
    }
  };

  return (
    <div dir="rtl" className="flex flex-col h-screen bg-slate-950 text-slate-100 font-sans overflow-hidden select-none">
       {/* Top Bar */}
      <div className="h-14 bg-slate-900 border-b border-slate-800 flex items-center justify-between px-4 z-20 shadow-md">
        <div className="flex items-center gap-2">
            <div className="w-8 h-8 bg-gradient-to-tr from-indigo-500 to-purple-500 rounded-md flex items-center justify-center font-bold">ع</div>
            <span className="font-bold hidden sm:

block">علی کوفی</span>
        </div>

        <div className="flex items-center gap-2">
             <button onClick={() => setGridSize(prev => prev === 16 ? 32 : prev === 32 ? 64 : 16)} className="flex items-center gap-2 px-3 py-1.5 text-xs bg-slate-800 rounded hover:bg-slate-700 transition-colors border border-slate-700">
                <Monitor size={14} />
                <span>{gridSize}×{gridSize}</span>
             </button>
             <div className="h-6 w-px bg-slate-700 mx-1"></div>
             <button onClick={undo} disabled={historyIndex === 0} className="p-2 text-slate-400 hover:text-white disabled:opacity-30"><Undo size={18}/></button>
             <button onClick={redo} disabled={historyIndex === history.length-1} className="p-2 text-slate-400 hover:text-white disabled:opacity-30"><Redo size={18}/></button>
        </div>

        <button onClick={handleExport} className="bg-green-600 hover:bg-green-500 text-white px-4 py-1.5 rounded-md text-xs font-bold flex items-center gap-2 shadow-lg shadow-green-900/50">
            <Download size={14} />
            <span>خروجی</span>
        </button>
      </div>

      <div className="flex-grow flex flex-col md:flex-row overflow-hidden">

        {/* Tools Sidebar /}
        <div className="w-full md:w-16 bg-slate-900 border-l border-slate-800 flex md:flex-col items-center p-2 gap-2 overflow-x-auto md:overflow-visible order-2 md:order-1 shrink-0">
             {[
                 { id: 'pencil', icon: Pencil, color: 'text-blue-400' },
                 { id: 'eraser', icon: Eraser, color: 'text-pink-400' },
                 { id: 'bucket', icon: PaintBucket, color: 'text-yellow-400' },
                 { id: 'picker', icon: Pipette, color: 'text-cyan-400' },
             ].map(t => (
                 <button 
                    key={t.id}
                    onClick={() => setTool(t.id)}
                    className={`p-3 rounded-xl transition-all ${tool === t.id ? 'bg-slate-800 shadow-inner ring-1 ring-white/20 ' + t.color : 'text-slate-500 hover:bg-slate-800/50 hover:text-slate-300'}`}
                 >
                     <t.icon size={22} />
                 </button>
             ))}

             <div className="w-px h-8 md:w-8 md:h-px bg-slate-800 mx-2 md:my-2"></div>

             <button onClick={() => setShowGrid(!showGrid)} className={`p-3 rounded-xl transition-all ${showGrid ? 'bg-indigo-900/50 text-indigo-300' : 'text-slate-500'}`}>
                 <Grid size={22} />
             </button>
             <button onClick={clearAll} className="p-3 rounded-xl text-red-500 hover:bg-red-900/20 md:mt-auto">
                 <Trash2 size={22} />
             </button>
        </div>

        {/ Canvas Area /}
        <div className="flex-grow bg-slate-950 relative overflow-hidden flex items-center justify-center p-4 order-1 md:order-2 touch-none" ref={containerRef}>
            {/ Background Pattern /}
            <div className="absolute inset-0 opacity-5 pointer-events-none" style={{ backgroundImage: 'radial-gradient(circle, #fff 1px, transparent 1px)', backgroundSize: '20px 20px' }}></div>

            <div className="relative shadow-2xl shadow-black rounded-sm border border-slate-800 bg-[#1a1a1a]">
                 <canvas
                    ref={canvasRef}
                    width={600}
                    height={600}
                    onMouseDown={handleStart}
                    onMouseMove={handleMove}
                    onMouseUp={handleEnd}
                    onMouseLeave={handleEnd}
                    onTouchStart={handleStart}
                    onTouchMove={handleMove}
                    onTouchEnd={handleEnd}
                    className="block cursor-crosshair touch-none max-w-full max-h-[70vh] md:max-h-[85vh] w-auto h-auto object-contain"
                    style={{ imageRendering: 'pixelated' }}
                 />
            </div>
        </div>

        {/ Color Palette Sidebar */}
        <div className="w-full md:w-64 bg-slate-900 border-r border-sl

ate-800 flex flex-col order-3 shrink-0">
             <div className="p-4 border-b border-slate-800">
                <div className="flex items-center gap-3 mb-4">
                    <div className="w-12 h-12 rounded-lg shadow-inner ring-1 ring-white/10" style={{ backgroundColor: selectedColor }}></div>
                    <div className="flex-1">
                        <label className="text-[10px] text-slate-500 font-bold uppercase tracking-wider mb-1 block">رنگ فعلی</label>
                        <div className="flex bg-slate-800 rounded p-1">
                            <input type="text" value={selectedColor} readOnly className="bg-transparent w-full text-xs font-mono text-center outline-none text-slate-300"/>
                            <input type="color" value={selectedColor} onChange={(e) => setSelectedColor(e.target.value)} className="w-6 h-4 opacity-0 absolute cursor-pointer"/>
                            <Palette size={14} className="text-slate-500"/>
                        </div>
                    </div>
                </div>
             </div>

             <div className="flex-grow overflow-y-auto p-4 space-y-4">
                {palettes.map((pal, i) => (
                    <div key={i}>
                        <label className="text-[10px] text-slate-500 font-bold uppercase tracking-wider mb-2 block">پالت کلاسیک {i+1}</label>
                        <div className="grid grid-cols-4 gap-2">
                            {pal.map(c => (
                                <button
                                    key={c}
                                    onClick={() => { setSelectedColor(c); setTool('pencil'); }}
                                    className={`aspect-square rounded-md transition-transform hover:scale-105 ${selectedColor === c ? 'ring-2 ring-white scale-110 z-10' : ''}`}
                                    style={{ backgroundColor: c }}
                                />
                            ))}
                        </div>
                    </div>
                ))}
             </div>
        </div>

      </div>
    </div>
  );
}
